// Generated by CoffeeScript 1.6.3
var add_checkbox_g_traymenu_item, add_checkbox_menu_item, add_g_traymenu_item, add_g_traymenu_seperator, add_menu_item, add_menu_seperator, add_output, cb_server_url, child_process, cryptobox_ctrl, cryptobox_locked_status_change, fs, g_encrypt_g_tray_item, g_menu, g_menuactions, g_output, g_progress_callback, g_second_counter, g_tray, g_trayactions, g_winmain, get_option, get_user_var, gui, on_exit, option_to_array, path, print, reset_bars, reset_bars_timer, run_cba_main, set_data_user_config, set_menus_and_g_tray_icon, set_motivation, set_user_var_scope, sleep, start_watch, store_user_var, update_sync_state, warning, watch,
  __slice = [].slice;

child_process = require("child_process");

path = require("path");

fs = require("fs");

watch = require("watch");

gui = require('nw.gui');

sleep = require('sleep');

g_output = [];

g_second_counter = 0;

g_encrypt_g_tray_item = null;

cb_server_url = "http://127.0.0.1:8000/";

g_winmain = gui.Window.get();

g_tray = new gui.Tray({
  icon: "images/icon-client-signed-in-idle.png"
});

g_menu = new gui.Menu({
  type: 'menubar'
});

g_trayactions = new gui.Menu();

g_tray.menu = g_trayactions;

g_menuactions = new gui.Menu();

g_winmain.menu = g_menu;

warning = function(ln, w) {
  if (w != null) {
    if ((w != null ? w.trim : void 0) != null) {
      w = w.trim();
    }
  } else {
    return;
  }
  if (exist(w)) {
    if (w.faultString != null) {
      return add_output(w.faultString);
    } else if (w.message) {
      return add_output(w.message);
    } else {
      return add_output(w);
    }
  }
};

add_output = function(msgs) {
  var add_msg;
  if (msgs.indexOf(".cf") >= 0) {
    msgs = "> " + msgs;
  }
  add_msg = function(msg) {
    if (msg.indexOf != null) {
      if (msg.indexOf("Error") === -1) {
        if (msg.indexOf("POST /RPC2") > 0) {
          return;
        }
      }
    }
    if (msg.replace != null) {
      msg = msg.replace("stderr:", "");
      msg.replace("\n", "");
      msg = msg.trim();
    }
    if (exist(msg)) {
      return g_output.push(msg);
    }
  };
  if ((msgs != null ? msgs.split : void 0) != null) {
    _.each(msgs.split("\n"), add_msg);
  } else if (msgs === "true") {
    pass;
  } else if (msgs === "false") {
    pass;
  } else if (msgs === true) {
    pass;
  } else if (msgs === false) {
    pass;
  } else {
    if (msgs != null) {
      g_output.push(msgs);
    }
  }
  console.log(msgs);
  return true;
};

print = function() {
  var len_others, msg, others;
  msg = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  len_others = _.size(others);
  switch (len_others) {
    case 0:
      return add_output(msg);
    case 1:
      return add_output(msg + " " + others[0]);
    case 2:
      return add_output(msg + " " + others[0] + " " + others[1]);
    case 3:
      return add_output(msg + " " + others[0] + " " + others[1] + " " + others[2]);
    case 4:
      return add_output(msg + " " + others[0] + " " + others[1] + " " + others[2] + " " + others[3]);
    case 5:
      return add_output(msg + " " + others[0] + " " + others[1] + " " + others[2] + " " + others[3] + " " + others[4]);
    default:
      add_output(others);
      return add_output(msg);
  }
};

warning = function(ln, w) {
  if (w != null) {
    if ((w != null ? w.trim : void 0) != null) {
      w = w.trim();
    }
  } else {
    return;
  }
  if (exist(w)) {
    if (w.faultString != null) {
      return add_output(w.faultString);
    } else if (w.message) {
      return add_output(w.message);
    } else {
      return add_output(w);
    }
  }
};

option_to_array = function(name, option) {
  var cmd_str, k, param_array, push_param_array, _i, _len, _ref;
  _ref = _.keys(option);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    k = _ref[_i];
    if (option[k] === true) {
      option[k] = "1";
    }
    if (option[k] === false) {
      option[k] = "0";
    }
  }
  cmd_str = "";
  if (option.acommand != null) {
    cmd_str += " --acommand " + option.acommand;
  }
  if (option.cryptobox != null) {
    cmd_str += " --cryptobox " + option.cryptobox;
  }
  if (option.clear != null) {
    cmd_str += " --clear " + option.clear;
  }
  if (option.decrypt != null) {
    cmd_str += " --decrypt " + option.decrypt;
  }
  if (option.encrypt != null) {
    cmd_str += " --encrypt " + option.encrypt;
  }
  if (option.dir != null) {
    cmd_str += " --dir " + option.dir;
  }
  if (option.logout != null) {
    cmd_str += " --logout " + option.logout;
  }
  if (option.motivation != null) {
    cmd_str += " --motivation " + option.motivation;
  }
  if (option.numdownloadthreads != null) {
    cmd_str += " --numdownloadthreads " + option.numdownloadthreads;
  }
  if (option.check != null) {
    cmd_str += " --check " + option.check;
  }
  if (option.password != null) {
    cmd_str += " --password " + option.password;
  }
  if (option.remove != null) {
    cmd_str += " --remove " + option.remove;
  }
  if (option.sync != null) {
    cmd_str += " --sync " + option.sync;
  }
  if (option.treeseq != null) {
    cmd_str += " --treeseq " + option.treeseq;
  }
  if (option.username != null) {
    cmd_str += " --username " + option.username;
  }
  if (option.version != null) {
    cmd_str += " --version " + option.version;
  }
  if (option.server != null) {
    cmd_str += " --server " + option.server;
  }
  print("cryptobox.cf:140", "python cba_main.py", cmd_str.trim());
  param_array = [];
  push_param_array = function(i) {
    if (_.size(i.trim()) > 0) {
      return param_array.push(i);
    }
  };
  _.each(cmd_str.split(" "), push_param_array);
  return param_array;
};

run_cba_main = function(name, options, cb, cb_stdout) {
  var cba_main, cmd_to_run, error, execution_done, output, params;
  if (!exist(cb)) {
    throw "run_cba_main needs a cb parameter (callback)";
  }
  params = option_to_array(name, options);
  cmd_to_run = path.join(process.cwd(), "commands");
  cmd_to_run = path.join(cmd_to_run, "cba_main");
  cba_main = child_process.spawn(cmd_to_run, params);
  output = "";
  error = "";
  cba_main.stdout.on("data", function(data) {
    var try_cb;
    if (cb_stdout != null) {
      if (String(data).indexOf("\n") >= 0) {
        data = String(data).split("\n");
        try_cb = function(datachunk) {
          if (datachunk != null) {
            if (_.size(datachunk) > 0) {
              return cb_stdout(datachunk);
            }
          }
        };
        return _.each(data, try_cb);
      } else {
        return cb_stdout(data);
      }
    } else {
      return output += data;
    }
  });
  cba_main.stderr.on("data", function(data) {
    return error += data;
  });
  execution_done = function(event) {
    var defer_callback,
      _this = this;
    defer_callback = function() {
      if (output.indexOf("Another instance is already running, quitting.") >= 0) {
        print("cryptobox.cf:181", "already running");
        return cb(false, output);
      } else {
        if (_.size(error) > 0) {
          print("cryptobox.cf:185", error);
          return cb(false, error);
        } else {
          if (event > 0) {
            return cb(false, output);
          } else {
            return cb(true, output);
          }
        }
      }
    };
    return setTimeout(defer_callback, 1);
  };
  return cba_main.on("exit", execution_done);
};

on_exit = function() {
  return gui.App.quit();
};

store_user_var = function(k, v, $q) {
  var db, p, record;
  p = $q.defer();
  db = new PouchDB('cb_userinfo');
  if (!exist(db)) {
    p.reject("no db");
  } else {
    record = {
      _id: k,
      value: v
    };
    db.get(k, function(e, d) {
      if (exist(d)) {
        if (exist(d._rev)) {
          record._rev = d._rev;
        }
      }
      return db.put(record, function(e, r) {
        if (exist(e)) {
          p.reject(e);
        }
        if (exist(r)) {
          if (exist_truth(r.ok)) {
            return p.resolve(true);
          } else {
            return p.reject(r);
          }
        } else {
          return p.reject("store_user_var generic error");
        }
      });
    });
  }
  return p.promise;
};

get_user_var = function(k, $q) {
  var db, p;
  p = $q.defer();
  db = new PouchDB('cb_userinfo');
  if (!exist(db)) {
    p.reject("no db");
  } else {
    db.get(k, function(e, d) {
      if (exist(e)) {
        return p.reject(e);
      } else {
        if (exist(d)) {
          return p.resolve(d.value);
        } else {
          return p.reject();
        }
      }
    });
  }
  return p.promise;
};

set_user_var_scope = function(name, scope_name, scope, $q) {
  var p;
  p = $q.defer();
  get_user_var(name, $q).then(function(v) {
    if (exist(scope_name)) {
      scope[scope_name] = v;
    } else {
      scope[name] = v;
    }
    return p.resolve();
  }, function(err) {
    warning("cryptobox.cf:261", err);
    return p.reject(err);
  });
  return p.promise;
};

set_data_user_config = function(scope, $q) {
  var p, promises;
  p = $q.defer();
  promises = [];
  promises.push(set_user_var_scope("cb_folder", "cb_folder_text", scope, $q));
  promises.push(set_user_var_scope("cb_username", null, scope, $q));
  promises.push(set_user_var_scope("cb_password", null, scope, $q));
  promises.push(set_user_var_scope("cb_name", null, scope, $q));
  promises.push(set_user_var_scope("cb_server", null, scope, $q));
  promises.push(set_user_var_scope("show_settings", null, scope, $q));
  promises.push(set_user_var_scope("show_debug", null, scope, $q));
  $q.all(promises).then(function() {
    if (!exist(scope.cb_server)) {
      scope.cb_server = cb_server_url;
    }
    return p.resolve();
  }, function(err) {
    return p.reject(err);
  });
  return p.promise;
};

update_sync_state = function(scope) {
  var option, result_sync_state;
  option = {
    dir: scope.cb_folder_text,
    username: scope.cb_username,
    password: scope.cb_password,
    cryptobox: scope.cb_name,
    server: scope.cb_server,
    check: true
  };
  result_sync_state = function(result, output) {
    var ex, sync_results;
    if (result) {
      try {
        sync_results = JSON.parse(output);
        if (sync_results.locked != null) {
          if (sync_results.locked) {
            cryptobox_locked_status_change(true, scope);
          }
        } else {
          cryptobox_locked_status_change(false, scope);
          scope.file_downloads = sync_results.file_downloads;
          scope.file_uploads = sync_results.file_uploads;
          scope.dir_del_server = sync_results.dir_del_server;
          scope.dir_make_local = sync_results.dir_make_local;
          scope.dir_make_server = sync_results.dir_make_server;
          scope.dir_del_local = sync_results.dir_del_local;
          scope.file_del_local = sync_results.file_del_local;
          scope.file_del_server = sync_results.file_del_server;
          if (sync_results.all_synced) {
            scope.disable_sync_button = true;
          } else {
            scope.disable_sync_button = false;
          }
        }
      } catch (_error) {
        ex = _error;
        print("cryptobox.cf:324", ex);
        print("cryptobox.cf:325", output);
      }
    }
    return result;
  };
  return run_cba_main("update_sync_state", option, result_sync_state);
};

start_watch = function(scope) {
  var last_watch, watch_path;
  last_watch = new Date().getTime();
  if (!scope.file_watch_started) {
    if (exist(scope.cb_folder_text) && exist(scope.cb_name)) {
      watch_path = path.join(scope.cb_folder_text, scope.cb_name);
      if (fs.existsSync(watch_path)) {
        scope.file_watch_started = true;
        return watch.watchTree(watch_path, function(f, curr, prev) {
          if (!String(f).contains("memory.pickle")) {
            if (typeof f === "object" && prev === null && curr === null) {
              return;
            }
            print("cryptobox.cf:344", "filechange", f);
            if (prev === null) {
              return scope.request_update_sync_state = true;
            } else if (curr.nlink === 0) {
              return scope.request_update_sync_state = true;
            } else {
              return scope.request_update_sync_state = true;
            }
          }
        });
      }
    }
  }
};

cryptobox_locked_status_change = function(locked, scope) {
  scope.cryptobox_locked = locked;
  if (scope.cryptobox_locked) {
    g_tray.icon = "images/icon-client-signed-out.png";
    scope.disable_encrypt_button = true;
    scope.disable_decrypt_button = false;
    scope.disable_sync_button = true;
    if (g_encrypt_g_tray_item != null) {
      return g_encrypt_g_tray_item.enabled = false;
    }
  } else {
    g_tray.icon = "images/icon-client-signed-in-idle.png";
    scope.disable_encrypt_button = false;
    scope.disable_decrypt_button = true;
    scope.disable_sync_button = false;
    if (g_encrypt_g_tray_item != null) {
      return g_encrypt_g_tray_item.enabled = true;
    }
  }
};

get_option = function($scope) {
  var option;
  option = {
    dir: $scope.cb_folder_text,
    username: $scope.cb_username,
    password: $scope.cb_password,
    cryptobox: $scope.cb_name,
    server: $scope.cb_server
  };
  return option;
};

add_g_traymenu_item = function(label, icon, method) {
  var g_trayitem;
  g_trayitem = new gui.MenuItem({
    type: "normal",
    label: label,
    icon: icon,
    click: method
  });
  g_trayactions.append(g_trayitem);
  return g_trayitem;
};

add_checkbox_g_traymenu_item = function(label, icon, method, enabled) {
  var g_trayitem_cb;
  g_trayitem_cb = new gui.MenuItem({
    type: "checkbox",
    label: label,
    icon: icon,
    click: method,
    checked: enabled
  });
  g_trayactions.append(g_trayitem_cb);
  return g_trayitem_cb;
};

add_g_traymenu_seperator = function() {
  var g_traymenubaritem;
  g_traymenubaritem = new gui.MenuItem({
    type: "separator"
  });
  g_trayactions.append(g_traymenubaritem);
  return g_traymenubaritem;
};

add_menu_item = function(label, icon, method) {
  var menubaritem;
  menubaritem = new gui.MenuItem({
    type: "normal",
    label: label,
    icon: icon,
    click: method
  });
  g_menuactions.append(menubaritem);
  return menubaritem;
};

add_checkbox_menu_item = function(label, icon, method, enabled) {
  var menubaritem_cb;
  menubaritem_cb = new gui.MenuItem({
    type: "checkbox",
    label: label,
    icon: icon,
    click: method,
    checked: enabled
  });
  g_menuactions.append(menubaritem_cb);
  return menubaritem_cb;
};

add_menu_seperator = function() {
  var menubaritem;
  menubaritem = new gui.MenuItem({
    type: "separator"
  });
  return g_menuactions.append(menubaritem);
};

set_menus_and_g_tray_icon = function(scope) {
  add_menu_seperator();
  add_g_traymenu_seperator();
  add_menu_item("Encrypt local", "images/lock.png", scope.encrypt_btn);
  g_encrypt_g_tray_item = add_g_traymenu_item("Encrypt local", "images/lock.png", scope.encrypt_btn);
  add_menu_item("Decrypt local", "images/unlock.png", scope.decrypt_btn);
  add_g_traymenu_item("Decrypt local", "images/unlock.png", scope.decrypt_btn);
  g_winmain.menu.insert(new gui.MenuItem({
    label: 'Actions',
    submenu: g_menuactions
  }), 1);
  scope.settings_menubaritem = add_checkbox_menu_item("Settings", "images/cog.png", scope.toggle_settings, scope.show_settings);
  scope.settings_menubar_g_tray = add_checkbox_g_traymenu_item("Settings", "images/cog.png", scope.toggle_settings, scope.show_settings);
  scope.update_menu_checks = function() {
    scope.settings_menubaritem.checked = scope.show_settings;
    return scope.settings_menubar_g_tray.checked = scope.show_settings;
  };
  return scope.$watch("show_settings", scope.update_menu_checks);
};

set_motivation = function($scope) {
  var motivation_cb;
  motivation_cb = function(result, output) {
    if (result) {
      return $scope.motivation = output.replace("\n", "<br/>");
    }
  };
  return run_cba_main("motivation", {
    "motivation": true
  }, motivation_cb);
};

g_progress_callback = function(scope, output) {
  var err, stored_output;
  stored_output = output;
  try {
    output = JSON.parse(output);
    if (output.global_progress != null) {
      scope.progress_bar = output.global_progress;
    }
    if (output.item_progress != null) {
      scope.progress_bar_item = output.item_progress;
    }
    if (output.msg != null) {
      return scope.progress_message = output.msg;
    }
  } catch (_error) {
    err = _error;
    print("cryptobox.cf:486", "error");
    print("cryptobox.cf:487", stored_output);
    return print("cryptobox.cf:488", err);
  }
};

reset_bars_timer = null;

reset_bars = function(scope) {
  var now;
  if (reset_bars_timer == null) {
    if (scope.progress_bar >= 100) {
      return reset_bars_timer = new Date().getTime();
    }
  } else {
    now = new Date().getTime();
    if (now - reset_bars_timer > 2000) {
      scope.progress_bar = 0;
      scope.progress_bar_item = 0;
      scope.progress_message = "";
      return reset_bars_timer = null;
    }
  }
};

angular.module("cryptoboxApp", ["cryptoboxApp.base", "angularFileUpload"]);

cryptobox_ctrl = function($scope, memory, utils, $q) {
  var digester, once_motivation, progress_callback;
  $scope.cba_version = 0.1;
  $scope.cba_main = null;
  $scope.quitting = false;
  $scope.motivation = null;
  $scope.progress_bar = 0;
  $scope.progress_bar_item = 0;
  $scope.progress_message = "";
  $scope.show_settings = false;
  $scope.show_debug = false;
  $scope.got_cb_name = false;
  $scope.file_downloads = [];
  $scope.file_uploads = [];
  $scope.dir_del_server = [];
  $scope.dir_make_local = [];
  $scope.dir_make_server = [];
  $scope.dir_del_local = [];
  $scope.file_del_local = [];
  $scope.file_del_server = [];
  $scope.disable_encrypt_button = true;
  $scope.disable_decrypt_button = true;
  $scope.disable_sync_button = true;
  $scope.file_watch_started = false;
  $scope.request_update_sync_state = false;
  $scope.state_syncing = false;
  g_winmain.on('close', on_exit);
  $scope.debug_btn = function() {
    return require('nw.gui').Window.get().showDevTools();
  };
  $scope.get_progress_item_show = function() {
    return $scope.progress_bar_item !== 0;
  };
  $scope.get_progress_item = function() {
    return {
      width: $scope.progress_bar_item + "%"
    };
  };
  $scope.get_progress = function() {
    return {
      width: $scope.progress_bar + "%"
    };
  };
  $scope.toggle_debug = function() {
    $scope.show_debug = !$scope.show_debug;
    return $scope.form_save();
  };
  $scope.form_changed = false;
  $scope.form_change = function() {
    return $scope.form_changed = true;
  };
  $scope.form_save = function() {
    store_user_var("cb_folder", $scope.cb_folder_text, $q);
    store_user_var("cb_username", $scope.cb_username, $q);
    store_user_var("cb_password", $scope.cb_password, $q);
    store_user_var("cb_name", $scope.cb_name, $q);
    store_user_var("cb_server", $scope.cb_server, $q);
    store_user_var("show_settings", $scope.show_settings, $q);
    store_user_var("show_debug", $scope.show_debug, $q);
    return $scope.form_changed = false;
  };
  $scope.file_input_change = function(f) {
    $scope.cb_folder_text = f[0].path;
    return $scope.form_save();
  };
  $scope.sync_btn = function() {
    var option, sync_cb;
    print("cryptobox.cf:572", "start sync");
    $scope.disable_sync_button = true;
    option = get_option($scope);
    option.encrypt = true;
    option.clear = false;
    option.sync = true;
    $scope.state_syncing = true;
    $scope.disable_sync_button = true;
    sync_cb = function(result, output) {
      if (result) {
        print("cryptobox.cf:583", "sync ok");
        $scope.state_syncing = false;
        $scope.disable_sync_button = false;
        $scope.progress_bar_item = 100;
        $scope.progress_bar_item = 100;
        return $scope.request_update_sync_state = true;
      }
    };
    return run_cba_main("sync server", option, sync_cb, progress_callback);
  };
  $scope.encrypt_btn = function() {
    var option, sync_cb;
    option = get_option($scope);
    option.encrypt = true;
    option.remove = true;
    option.sync = false;
    $scope.disable_sync_button = true;
    sync_cb = function(result, output) {
      if (result) {
        print("cryptobox.cf:600", "encrypted");
        $scope.request_update_sync_state = true;
        $scope.progress_bar_item = 100;
        return $scope.progress_bar_item = 100;
      }
    };
    return run_cba_main("encrypt", option, sync_cb, progress_callback);
  };
  progress_callback = function(output) {
    return g_progress_callback($scope, output);
  };
  $scope.decrypt_btn = function() {
    var option, sync_cb;
    option = get_option($scope);
    option.decrypt = true;
    $scope.disable_sync_button = true;
    sync_cb = function(result, output) {
      if (result) {
        print("cryptobox.cf:616", "decrypted");
        $scope.disable_sync_button = true;
        $scope.request_update_sync_state = true;
        $scope.progress_bar_item = 100;
        return $scope.progress_bar_item = 100;
      }
    };
    return run_cba_main("decrypt", option, sync_cb, progress_callback);
  };
  $scope.open_folder = function() {
    var open_cb, option;
    option = get_option($scope);
    option.acommand = "open_folder";
    open_cb = function(result, output) {
      return print("cryptobox.cf:628", result, output);
    };
    return run_cba_main("open_folder", option, open_cb);
  };
  $scope.open_website = function() {
    return gui.Shell.openExternal($scope.cb_server + $scope.cb_name);
  };
  $scope.toggle_settings = function() {
    $scope.show_settings = !$scope.show_settings;
    return $scope.form_save();
  };
  $scope.clear_msg_buffer = function() {
    g_output = [];
    return utils.force_digest($scope);
  };
  set_data_user_config($scope, $q).then(function() {
    update_sync_state($scope);
    return start_watch($scope);
  }, function(err) {
    print("cryptobox.cf:648", err);
    throw "set data user config error";
  });
  once_motivation = _.once(set_motivation);
  once_motivation($scope);
  set_menus_and_g_tray_icon($scope);
  digester = function() {
    var make_stream, output_msg;
    output_msg = "";
    make_stream = function(msg) {
      return output_msg += msg + "\n";
    };
    _.each(g_output, make_stream);
    $scope.cmd_output = output_msg;
    utils.force_digest($scope);
    if ($scope.request_update_sync_state) {
      if (update_sync_state($scope)) {
        $scope.request_update_sync_state = false;
      }
    }
    return reset_bars($scope);
  };
  return setInterval(digester, 250);
};
