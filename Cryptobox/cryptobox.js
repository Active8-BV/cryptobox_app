// Generated by CoffeeScript 1.6.3
var child_process, cryptobox_ctrl, gui, path, print, tray, watch, xmlrpc,
  __slice = [].slice;

child_process = require("child_process");

path = require("path");

gui = require('nw.gui');

xmlrpc = require('xmlrpc');

gui = require("nw.gui");

watch = require("watch");

print = function() {
  var len_others, msg, others;
  msg = arguments[0], others = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  len_others = _.size(others);
  switch (len_others) {
    case 0:
      return typeof console !== "undefined" && console !== null ? console.log(msg) : void 0;
    case 1:
      return typeof console !== "undefined" && console !== null ? console.log(msg + " " + others[0]) : void 0;
    case 2:
      return typeof console !== "undefined" && console !== null ? console.log(msg + " " + others[0] + " " + others[1]) : void 0;
    case 3:
      return typeof console !== "undefined" && console !== null ? console.log(msg + " " + others[0] + " " + others[1] + " " + others[2]) : void 0;
    case 4:
      return typeof console !== "undefined" && console !== null ? console.log(msg + " " + others[0] + " " + others[1] + " " + others[2] + " " + others[3]) : void 0;
    case 5:
      return typeof console !== "undefined" && console !== null ? console.log(msg + " " + others[0] + " " + others[1] + " " + others[2] + " " + others[3] + " " + others[4]) : void 0;
    default:
      return typeof console !== "undefined" && console !== null ? console.log(others, msg) : void 0;
  }
};

tray = new gui.Tray({
  icon: "images/icon-client-signed-in-idle.png"
});

angular.module("cryptoboxApp", ["cryptoboxApp.base", "angularFileUpload"]);

cryptobox_ctrl = function($scope, $q, memory, utils) {
  var actions, add_checkbox_menu_item, add_checkbox_traymenu_item, add_menu_item, add_menu_seperator, add_output, add_traymenu_item, add_traymenu_seperator, cba_main, cmd_to_run, cryptobox_locked_status_change, encrypt_tray_item, get_motivation, get_progress, get_rpc_client, get_sync_state, get_user_var, get_val, get_working_state, last_progress_bar, last_progress_bar_item, menubar, output, ping_client, progress_bar, progress_bar_item, reset_item_progress, reset_progress, run_command, second_counter, second_interval, set_data_user_config, set_data_user_config_once, set_output_buffers, set_user_var_scope, set_val, settings_menubar_tray, settings_menubaritem, spawn, start_process, start_process_once, start_second_interval, start_watch, store_user_var, trayactions, try_get_sync_state, update_menu_checks, update_output, update_sync_state, warning, winmain,
    _this = this;
  print("cryptobox.cf:37", "cryptobox_ctrl");
  get_rpc_client = function() {
    var clientOptions;
    clientOptions = {
      host: "localhost",
      port: 8654,
      path: "/RPC2"
    };
    return xmlrpc.createClient(clientOptions);
  };
  set_val = function(k, v) {
    var client, p;
    p = $q.defer();
    client = get_rpc_client();
    client.methodCall("set_val", [k, v], function(error, value) {
      if (exist(error)) {
        p.reject(error);
      } else {
        if (utils.exist_truth(value)) {
          p.resolve("set_val " + k + ":" + v);
          utils.force_digest($scope);
        } else {
          p.reject("error set_val");
          utils.force_digest($scope);
        }
      }
      return utils.force_digest($scope);
    });
    return p.promise;
  };
  get_val = function(k) {
    var client, p;
    p = $q.defer();
    client = get_rpc_client();
    client.methodCall("get_val", [k], function(error, value) {
      if (exist(error)) {
        p.reject(error);
        return utils.force_digest($scope);
      } else {
        p.resolve(value);
        return utils.force_digest($scope);
      }
    });
    return p.promise;
  };
  $scope.cba_version = 0.1;
  memory.set("g_running", true);
  cba_main = null;
  $scope.on_exit = function() {
    var client;
    print("cryptobox.cf:80", "cryptobox app on_exit");
    client = get_rpc_client();
    return client.methodCall("force_stop", [], function(e, v) {
      var force_kill,
        _this = this;
      force_kill = function() {
        if (cba_main != null) {
          if (cba_main.pid != null) {
            add_output("force kill!!!");
            process.kill(cba_main.pid);
            return gui.App.quit();
          }
        }
      };
      return utils.set_time_out("cryptobox.cf:90", force_kill, 100);
    });
  };
  set_output_buffers = function(cba_main_proc) {
    if (exist(cba_main_proc.stdout)) {
      cba_main_proc.stdout.on("data", function(data) {
        return add_output("stdout:" + data);
      });
    }
    if (exist(cba_main_proc.stderr)) {
      return cba_main_proc.stderr.on("data", function(data) {
        return add_output("stderr:" + data);
      });
    }
  };
  winmain = gui.Window.get();
  winmain.on('close', $scope.on_exit);
  spawn = require("child_process").spawn;
  cmd_to_run = path.join(process.cwd(), "commands");
  cmd_to_run = path.join(cmd_to_run, "cba_main");
  output = [];
  $scope.clear_msg_buffer = function() {
    output = [];
    return utils.force_digest($scope);
  };
  $scope.debug_btn = function() {
    return require('nw.gui').Window.get().showDevTools();
  };
  update_output = function() {
    var make_stream, msgs;
    msgs = "";
    make_stream = function(msg) {
      return msgs += msg + "\n";
    };
    _.each(output, make_stream);
    $scope.cmd_output = msgs;
    return utils.force_digest($scope);
  };
  add_output = function(msgs) {
    var add_msg;
    add_msg = function(msg) {
      if (msg.indexOf != null) {
        if (msg.indexOf("Error") === -1) {
          if (msg.indexOf("POST /RPC2") > 0) {
            return;
          }
        }
      }
      if (msg.replace != null) {
        msg = msg.replace("stderr:", "");
        msg.replace("\n", "");
        msg = msg.trim();
      }
      if (utils.exist(msg)) {
        return output.unshift(utils.format_time(utils.get_local_time()) + ": " + msg);
      }
    };
    if ((msgs != null ? msgs.split : void 0) != null) {
      _.each(msgs.split("\n"), add_msg);
    } else if (msgs === "true") {
      pass;
    } else if (msgs === "false") {
      pass;
    } else if (msgs === true) {
      pass;
    } else if (msgs === false) {
      pass;
    } else {
      if (msgs != null) {
        output.push(utils.format_time(utils.get_local_time()) + ": " + msgs);
      }
    }
    return update_output();
  };
  warning = function(ln, w) {
    if (w != null) {
      if ((w != null ? w.trim : void 0) != null) {
        w = w.trim();
      }
    } else {
      return;
    }
    if (utils.exist(w)) {
      if (w.faultString != null) {
        return add_output(w.faultString);
      } else if (w.message) {
        return add_output(w.message);
      } else {
        return add_output(w);
      }
    }
  };
  $scope.motivation = null;
  get_motivation = function() {
    var client;
    if (!utils.exist($scope.motivation)) {
      client = get_rpc_client();
      return client.methodCall("get_motivation", [], function(error, value) {
        if (utils.exist(value)) {
          $scope.motivation = value;
        }
        if (!utils.exist($scope.motivation)) {
          return utils.set_time_out("cryptobox.cf:179", get_motivation, 100);
        }
      });
    }
  };
  utils.set_time_out("cryptobox.cf:181", get_motivation, 500);
  ping_client = function() {
    var client;
    utils.force_digest($scope);
    client = get_rpc_client();
    return client.methodCall("last_ping", [], function(error, value) {
      if (utils.exist(error)) {
        cba_main = spawn(cmd_to_run, [""]);
        return set_output_buffers(cba_main);
      } else {
        return $scope.rpc_server_started = true;
      }
    });
  };
  $scope.rpc_server_started = false;
  start_process = function() {
    var client;
    print("cryptobox.cf:196", "start_process");
    client = get_rpc_client();
    return client.methodCall("force_stop", [], function(e, v) {
      if (utils.exist(v)) {
        print("cryptobox.cf:200", "killed existing deamon");
      } else {
        print("cryptobox.cf:202", "starting deamon");
      }
      cba_main = spawn(cmd_to_run, [""]);
      return set_output_buffers(cba_main);
    });
  };
  start_process_once = _.once(start_process);
  print("cryptobox.cf:208", cmd_to_run);
  start_process_once();
  progress_bar = 0;
  progress_bar_item = 0;
  $scope.get_progress_item_show = function() {
    return progress_bar_item !== 0;
  };
  $scope.get_progress_item = function() {
    return {
      width: progress_bar_item + "%"
    };
  };
  $scope.get_progress = function() {
    return {
      width: progress_bar + "%"
    };
  };
  reset_progress = function() {
    var client;
    client = get_rpc_client();
    return client.methodCall("reset_progress", [], function(e, v) {
      if (utils.exist(e)) {
        return warning("cryptobox.cf:228", e);
      }
    });
  };
  reset_item_progress = function() {
    var client;
    client = get_rpc_client();
    return client.methodCall("reset_item_progress", [], function(e, v) {
      if (utils.exist(e)) {
        return warning("cryptobox.cf:234", e);
      }
    });
  };
  $scope.lock_buttons = false;
  $scope.get_lock_buttons = function() {
    return $scope.lock_buttons;
  };
  get_working_state = function() {
    var client;
    client = get_rpc_client();
    return client.methodCall("get_smemory", ["working"], function(e, v) {
      if (utils.exist(e)) {
        return warning("cryptobox.cf:245", e);
      } else {
        return $scope.lock_buttons = v;
      }
    });
  };
  last_progress_bar = 0;
  last_progress_bar_item = 0;
  get_progress = function() {
    var client;
    if (!$scope.rpc_server_started) {
      return;
    }
    client = get_rpc_client();
    client.methodCall("get_progress", [], function(e, v) {
      var progress, progress_item, reset_progress_bar, reset_progress_bar_item;
      if (utils.exist(e)) {
        warning("cryptobox.cf:259", e);
      } else {
        progress = parseInt(v[0], 10);
        progress_item = parseInt(v[1], 10);
      }
      last_progress_bar = progress_bar;
      last_progress_bar_item = progress_bar_item;
      if (progress === 0) {
        if (last_progress_bar > 10) {
          progress_bar = 100;
        }
      }
      if (progress_item === 0) {
        if (last_progress_bar_item > 10) {
          progress_bar_item = 100;
        }
      }
      if (progress > parseInt(progress_bar, 10)) {
        progress_bar = progress;
      }
      if (progress_item > parseInt(progress_bar_item, 10)) {
        progress_bar_item = progress_item;
      }
      if (progress_bar >= 100) {
        reset_progress_bar = function() {
          progress_bar = 0;
          return reset_progress();
        };
        utils.set_time_out("cryptobox.cf:286", reset_progress_bar, 500);
      }
      if (progress_bar_item >= 100) {
        reset_progress_bar_item = function() {
          progress_bar_item = 0;
          return reset_item_progress();
        };
        return utils.set_time_out("cryptobox.cf:293", reset_progress_bar_item, 500);
      }
    });
    return utils.force_digest($scope);
  };
  store_user_var = function(k, v) {
    var db, p, record;
    p = $q.defer();
    db = new PouchDB('cb_userinfo');
    if (!exist(db)) {
      p.reject("no db");
    } else {
      record = {
        _id: k,
        value: v
      };
      db.get(k, function(e, d) {
        if (exist(d)) {
          if (exist(d._rev)) {
            record._rev = d._rev;
          }
        }
        return db.put(record, function(e, r) {
          if (exist(e)) {
            p.reject(e);
            utils.force_digest($scope);
          }
          if (exist(r)) {
            if (exist_truth(r.ok)) {
              p.resolve(true);
              return utils.force_digest($scope);
            } else {
              p.reject(r);
              return utils.force_digest($scope);
            }
          } else {
            p.reject("store_user_var generic error");
            return utils.force_digest($scope);
          }
        });
      });
    }
    return p.promise;
  };
  get_user_var = function(k) {
    var db, p;
    p = $q.defer();
    db = new PouchDB('cb_userinfo');
    if (!exist(db)) {
      p.reject("no db");
    } else {
      db.get(k, function(e, d) {
        if (exist(e)) {
          return p.reject(e);
        } else {
          if (exist(d)) {
            p.resolve(d.value);
            return utils.force_digest($scope);
          } else {
            return p.reject();
          }
        }
      });
    }
    return p.promise;
  };
  set_user_var_scope = function(name, scope_name) {
    var p;
    p = $q.defer();
    get_user_var(name).then(function(v) {
      if (exist(scope_name)) {
        $scope[scope_name] = v;
      } else {
        $scope[name] = v;
      }
      return p.resolve();
    }, function(err) {
      warning("cryptobox.cf:361", err);
      return p.reject();
    });
    return p.promise;
  };
  $scope.show_settings = false;
  $scope.show_debug = false;
  $scope.toggle_debug = function() {
    $scope.show_debug = !$scope.show_debug;
    return $scope.form_change();
  };
  $scope.got_folder_text = false;
  $scope.got_cb_name = false;
  try_get_sync_state = function() {
    return get_sync_state().then(function(r) {
      return print("cryptobox.cf:379", "sync state retrieved");
    }, function(e) {
      return warning("cryptobox.cf:382", e);
    });
  };
  utils.set_time_out("cryptobox.cf:384", try_get_sync_state, 1000);
  start_watch = function() {
    if ($scope.got_folder_text && $scope.got_cb_name) {
      return watch.watchTree(path.join($scope.cb_folder_text, $scope.cb_name), function(f, curr, prev) {
        if (!String(f).contains("memory.pickle")) {
          if (typeof f === "object" && prev === null && curr === null) {
            return pass;
          } else if (prev === null) {
            return try_get_sync_state();
          } else if (curr.nlink === 0) {
            return try_get_sync_state();
          } else {
            return try_get_sync_state();
          }
        }
      });
    }
  };
  set_data_user_config = function() {
    set_user_var_scope("cb_folder", "cb_folder_text").then(function() {
      $scope.got_folder_text = true;
      return start_watch();
    });
    set_user_var_scope("cb_username");
    set_user_var_scope("cb_password");
    set_user_var_scope("cb_name").then(function() {
      $scope.got_cb_name = true;
      return start_watch();
    });
    set_user_var_scope("cb_server");
    set_user_var_scope("show_settings");
    set_user_var_scope("show_debug");
    if (!utils.exist($scope.cb_username)) {
      $scope.show_settings = true;
    }
    if (!utils.exist($scope.cb_server)) {
      return $scope.cb_server = "http://127.0.0.1:8000/";
    }
  };
  set_data_user_config_once = _.once(set_data_user_config);
  set_data_user_config_once();
  $scope.$on("$includeContentLoaded", function(event) {
    return typeof console !== "undefined" && console !== null ? console.log(event) : void 0;
  });
  $scope.form_change = function() {
    var p_cb_folder, p_cb_name, p_cb_password, p_cb_server, p_cb_username, p_show_debug, p_show_settings;
    p_cb_folder = store_user_var("cb_folder", $scope.cb_folder_text);
    p_cb_username = store_user_var("cb_username", $scope.cb_username);
    p_cb_password = store_user_var("cb_password", $scope.cb_password);
    p_cb_name = store_user_var("cb_name", $scope.cb_name);
    p_cb_server = store_user_var("cb_server", $scope.cb_server);
    p_show_settings = store_user_var("show_settings", $scope.show_settings);
    p_show_debug = store_user_var("show_debug", $scope.show_debug);
    return $q.all([p_cb_folder, p_cb_username, p_cb_password, p_cb_name, p_cb_server, p_show_settings, p_show_debug]).then(function() {
      return utils.force_digest($scope);
    }, function(err) {
      return warning("cryptobox.cf:444", err);
    });
  };
  $scope.file_input_change = function(f) {
    $scope.cb_folder_text = f[0].path;
    return $scope.form_change();
  };
  run_command = function(command_name, command_arguments) {
    var client, p;
    client = get_rpc_client();
    p = $q.defer();
    client.methodCall(command_name, command_arguments, function(error, value) {
      var bsca, ca_str;
      if (exist(error)) {
        ca_str = "";
        bsca = function(i) {
          if (_.isObject(i)) {
            return _.each(_.keys(i), function(k) {
              return ca_str = ca_str + k + ":" + i[k] + "|";
            });
          } else {
            return ca_str = ca_str + i;
          }
        };
        _.each(command_arguments, bsca);
        add_output(command_name + " " + ca_str + " " + error);
        p.reject(error);
        return utils.force_digest($scope);
      } else {
        p.resolve(value);
        return utils.force_digest($scope);
      }
    });
    return p.promise;
  };
  $scope.file_downloads = [];
  $scope.file_uploads = [];
  $scope.dir_del_server = [];
  $scope.dir_make_local = [];
  $scope.dir_make_server = [];
  $scope.dir_del_local = [];
  $scope.file_del_local = [];
  $scope.file_del_server = [];
  cryptobox_locked_status_change = function() {
    return run_command("get_cryptobox_lock_status", []).then(function(r) {
      $scope.cryptobox_locked = r;
      if ($scope.cryptobox_locked) {
        tray.icon = "images/icon-client-signed-out.png";
        $scope.disable_encrypt_button = true;
        $scope.disable_decrypt_button = false;
        $scope.disable_sync_button = true;
        return encrypt_tray_item.enabled = false;
      } else {
        tray.icon = "images/icon-client-signed-in-idle.png";
        $scope.disable_encrypt_button = false;
        $scope.disable_decrypt_button = true;
        $scope.disable_sync_button = false;
        return encrypt_tray_item.enabled = true;
      }
    }, function(e) {
      return warning("cryptobox.cf:502", e);
    });
  };
  get_sync_state = function() {
    var option, p;
    p = $q.defer();
    option = {
      dir: $scope.cb_folder_text,
      username: $scope.cb_username,
      password: $scope.cb_password,
      cryptobox: $scope.cb_name,
      server: $scope.cb_server,
      check: "1"
    };
    run_command("cryptobox_command", [option]).then(function(res) {
      return p.resolve();
    }, function(err) {
      return p.reject(err);
    });
    return p.promise;
  };
  update_sync_state = function() {
    run_command("get_smemory", ["file_downloads"]).then(function(r) {
      return $scope.file_downloads = r;
    }, function(e) {
      return warning("cryptobox.cf:530", e);
    });
    run_command("get_smemory", ["file_uploads"]).then(function(r) {
      return $scope.file_uploads = r;
    }, function(e) {
      return warning("cryptobox.cf:538", e);
    });
    run_command("get_smemory", ["dir_del_server"]).then(function(r) {
      return $scope.dir_del_server = r;
    }, function(e) {
      return warning("cryptobox.cf:546", e);
    });
    run_command("get_smemory", ["dir_make_local"]).then(function(r) {
      return $scope.dir_make_local = r;
    }, function(e) {
      return warning("cryptobox.cf:554", e);
    });
    run_command("get_smemory", ["dir_make_server"]).then(function(r) {
      return $scope.dir_make_server = r;
    }, function(e) {
      return warning("cryptobox.cf:562", e);
    });
    run_command("get_smemory", ["dir_del_local"]).then(function(r) {
      return $scope.dir_del_local = r;
    }, function(e) {
      return warning("cryptobox.cf:570", e);
    });
    run_command("get_smemory", ["file_del_local"]).then(function(r) {
      return $scope.file_del_local = r;
    }, function(e) {
      return warning("cryptobox.cf:578", e);
    });
    return run_command("get_smemory", ["file_del_server"]).then(function(r) {
      return $scope.file_del_server = r;
    }, function(e) {
      return warning("cryptobox.cf:586", e);
    });
  };
  $scope.sync_btn = function() {
    var option;
    add_output("syncing data");
    option = {
      dir: $scope.cb_folder_text,
      username: $scope.cb_username,
      password: $scope.cb_password,
      cryptobox: $scope.cb_name,
      server: $scope.cb_server,
      encrypt: true,
      clear: "0",
      sync: "1"
    };
    return run_command("cryptobox_command", [option]).then(function(res) {
      if (!utils.exist_truth(res)) {
        return add_output(res);
      } else {
        return add_output("done syncing");
      }
    }, function(err) {
      return warning("cryptobox.cf:609", err);
    });
  };
  $scope.encrypt_btn = function() {
    var option;
    add_output("sync encrypt remove data");
    option = {
      dir: $scope.cb_folder_text,
      username: $scope.cb_username,
      password: $scope.cb_password,
      cryptobox: $scope.cb_name,
      server: $scope.cb_server,
      encrypt: true,
      remove: true,
      sync: false
    };
    return run_command("cryptobox_command", [option]).then(function(res) {
      return add_output(res);
    }, function(err) {
      return warning("cryptobox.cf:629", err);
    });
  };
  $scope.decrypt_btn = function() {
    var option;
    add_output("decrypt local data");
    option = {
      dir: $scope.cb_folder_text,
      username: $scope.cb_username,
      password: $scope.cb_password,
      cryptobox: $scope.cb_name,
      server: $scope.cb_server,
      decrypt: true,
      clear: false
    };
    return run_command("cryptobox_command", [option]).then(function(res) {
      add_output(res);
      return add_output("done decrypting");
    }, function(err) {
      return warning("cryptobox.cf:649", err);
    });
  };
  $scope.open_folder = function() {
    return run_command("do_open_folder", [$scope.cb_folder_text, $scope.cb_name]);
  };
  $scope.open_website = function() {
    return gui.Shell.openExternal($scope.cb_server + $scope.cb_name);
  };
  trayactions = new gui.Menu();
  tray.menu = trayactions;
  add_traymenu_item = function(label, icon, method) {
    var trayitem;
    trayitem = new gui.MenuItem({
      type: "normal",
      label: label,
      icon: icon,
      click: method
    });
    trayactions.append(trayitem);
    return trayitem;
  };
  add_checkbox_traymenu_item = function(label, icon, method, enabled) {
    var trayitem_cb;
    trayitem_cb = new gui.MenuItem({
      type: "checkbox",
      label: label,
      icon: icon,
      click: method,
      checked: enabled
    });
    trayactions.append(trayitem_cb);
    return trayitem_cb;
  };
  add_traymenu_seperator = function() {
    var traymenubaritem;
    traymenubaritem = new gui.MenuItem({
      type: "separator"
    });
    trayactions.append(traymenubaritem);
    return traymenubaritem;
  };
  menubar = new gui.Menu({
    type: 'menubar'
  });
  actions = new gui.Menu();
  add_menu_item = function(label, icon, method) {
    var menubaritem;
    menubaritem = new gui.MenuItem({
      type: "normal",
      label: label,
      icon: icon,
      click: method
    });
    actions.append(menubaritem);
    return menubaritem;
  };
  add_checkbox_menu_item = function(label, icon, method, enabled) {
    var menubaritem_cb;
    menubaritem_cb = new gui.MenuItem({
      type: "checkbox",
      label: label,
      icon: icon,
      click: method,
      checked: enabled
    });
    actions.append(menubaritem_cb);
    return menubaritem_cb;
  };
  add_menu_seperator = function() {
    var menubaritem;
    menubaritem = new gui.MenuItem({
      type: "separator"
    });
    return actions.append(menubaritem);
  };
  $scope.toggle_settings = function() {
    $scope.show_settings = !$scope.show_settings;
    return $scope.form_change();
  };
  settings_menubaritem = add_checkbox_menu_item("Settings", "images/cog.png", $scope.toggle_settings, $scope.show_settings);
  settings_menubar_tray = add_checkbox_traymenu_item("Settings", "images/cog.png", $scope.toggle_settings, $scope.show_settings);
  update_menu_checks = function() {
    settings_menubaritem.checked = $scope.show_settings;
    return settings_menubar_tray.checked = $scope.show_settings;
  };
  $scope.$watch("show_settings", update_menu_checks);
  add_menu_seperator();
  add_traymenu_seperator();
  add_menu_item("Encrypt local", "images/lock.png", $scope.encrypt_btn);
  encrypt_tray_item = add_traymenu_item("Encrypt local", "images/lock.png", $scope.encrypt_btn);
  add_menu_item("Decrypt local", "images/unlock.png", $scope.decrypt_btn);
  add_traymenu_item("Decrypt local", "images/unlock.png", $scope.decrypt_btn);
  winmain.menu = menubar;
  winmain.menu.insert(new gui.MenuItem({
    label: 'Actions',
    submenu: actions
  }), 1);
  $scope.disable_encrypt_button = false;
  $scope.disable_decrypt_button = false;
  $scope.disable_sync_button = false;
  second_counter = 0;
  second_interval = function() {
    if (!$scope.lock_buttons) {
      update_sync_state();
    }
    get_progress();
    get_working_state();
    update_output();
    cryptobox_locked_status_change();
    second_counter += 1;
    if (second_counter % 10 === 0) {
      return ping_client();
    }
  };
  start_second_interval = function() {
    return utils.set_interval("cryptobox.cf:758", second_interval, 1000, "second_interval");
  };
  return utils.set_time_out("cryptobox.cf:759", start_second_interval, 1000);
};
